# Учебный курс React JS. Полный Курс 2020 

[React documentation](https://reactjs.org/).

На основании этого видео

[![Основное видео](http://img.youtube.com/vi/xJZa2_aldDs/0.jpg)](http://www.youtube.com/watch?v=xJZa2_aldDs "Основное видео")

## Основные команды

### Создать новый проект

```bash
npx create-react-app <имя проект>
```
Будет создана папка с именем проекта и установлены все зависимости.
Вместо имени проекта можно использовать "." если мы находимся в текущей директории.


### `npm start`

Запускает приложение в режиме разработки.
Откройте  [http://localhost:3000](http://localhost:3000), чтобы просмотреть его в браузере.
Если вы внесете правки, страница перезагрузится. Вы также увидите любые ошибки в консоли браузера.


### `npm run build`

Создает приложение для производства в папку сборки `build`.
Он правильно связывает React в производственном режиме и оптимизирует сборку для достижения максимальной производительности.
Сборка минифицирована, а имена файлов включают хеши. Ваше приложение готово к развертыванию!


### `npm run eject`

Эта команда удалит из вашего проекта зависимость отдельной сборки.

При запуске копируются все файлы конфигурации и транзитивные зависимости (webpack, Babel, ESLint и т.д.) прямо в ваш проект, чтобы вы имели полный контроль над ними. 
Все команды, кроме `eject`, по-прежнему будут работать, но они будут указывать на скопированные сценарии, чтобы вы могли их настроить. На этом этапе вы сами по себе.

***Примечание: это односторонняя операция. После того, как вы `извлечете` проект, вы не можете вернуться!***

----------

## Библиотека prop-types

Предназначена для строгой типизации/валидации типов входящих props

### Установка 
```bash
npm i prop-types
```

### Примеры

```js
TodoList.propTypes = {
    todos: PropTypes.arrayOf(PropTypes.object).isRequired
} 
```
Где мы указываем что наша функция принимает `props` **todos** 
состоящий из массива объектов  ( `.arrayOf(PropTypes.object)` )
и это обязательный аргумент  ( `.isRequired` )

Примечание: `TodoList` - это название функции к которому мы добавляем свойство `propTypes` 
и соответственно функцию компонента мы указываем по дефолту ниже

```js
export default TodoList 
```

```js
TodoItem.propTypes = {
    todo: PropTypes.object.isRequired,
    index: PropTypes.number,
}
```
где 
`todo` - объект и он обязательный
`index` - целое число



----------

## Hook useState

Нужен для хранения состояния

### Использование

Каждую переменную отвечающую за состояние оборачиваем `React.useState` куда передаем первичное состояние.

Этот кух вернет нам массив, где
1-й элемент - это переменная хранящая состояни
2-й элемент - это функция для изменения этого состояния

Пример
```js
const [todos, setTodos] = React.useState([
    {id: 1, completed: false, title: 'купить хлеб'},	 
    {id: 2, completed: false, title: 'купить масло'},	 
    {id: 3, completed: false, title: 'купить молоко'},	 
])
```

Ниже можем изменять состояние
```js
setTodos(todos.filter(todo => { return todo.id !== 5 }))
```

----------

## Context

Это глобальная область видимости для всего приложения. Чаще всего здесь хранятся ссылки на колбек-функции.
Позволяет получать доступ в любом компоненте элементы из родительского, где какой-либо предок обернут тегами

```jsx
<Context.Provider value={{removeTodo}}>
    ...
</Context.Provider>
```

В данном примере мы из родительского компонента `App` передаем ссылку на функцию `removeTodo`.

### Использование

Чтоб получить в нужном компоненте ее, надо:

1. Cоздаем файл `context.js`, где объявляем сам контекст 

```js
import React from "react"
export default React.createContext()
```

2. Подключаем в родительский и передаем через тег  `<Context.Provider value={{removeTodo}}>` нужные методы
 
3. В нужном компоненте использовать хук `useContext`

```jsx
import Context from "../context";
const {removeTodo} = useContext(Context)

... 

return (
    <button onClick={removeTodo.bind(null, todo.id)}>&times;</button>
)

// или

return (
    <button onClick={() => removeTodo(todo.id)}>&times;</button>
)
```



----------

## Свои Hooks

Оформляются в виде функции, которая инкапсулирует всю логику поведения.


### Использование
К примеру у нас есть input c обработчиком

```js
 <input type="text" value={value} onChange={event => { setValue(event.target.value) }}/>
```

Мы выносим всю логику в новый хук. по конвенции все названия хуков должны начинаться `use`
```js
function useInputValue(defaultValue = '') {
    const [value, setValue] = useState(defaultValue)
    return {
        bind: {
            value,
            onChange: event => {
                setValue(event.target.value)
            }
        },
        clear: () => setValue(''),
        value: () => value,
    }
}
```
В данном примере в аргумент передается начальное значение, 
которое мы передаем во внутренние переменные по работе с состоянием.

Инициализируем и получаем ссылку на наш хук
```js
const input = useInputValue('')
```

Дальше перепишем первоначальный input, теперь его поля можем указать через деструктуризацию  `...input.bind`
```js
<input {...input.bind}/>
```

К тому же как видно из примера. у нас есть два метода:
    `clear` - очистить `input.clear()`
    `value` - прочитать значение `input.value()`



----------

## Hook useEffect

[Подробней](https://www.youtube.com/watch?v=hwPo6OLBbD8).

Запускается каждый раз когда происходят изменения в зависимостях
Часто используется для асинхронного получения данных или в качестве обработчика изменений

### Использование

В первый аргумент `useEffect` передаем колбек-функцию обработки, вторым - массив зависимостей
```js
useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/todos?_limit=5')
        .then(response => response.json())
        .then(json => {
            setTimeout(() => {
                setTodos(json)
                setLoading(false)
            }, 2000)
        })
}, [])
```
В данном примере массив зависимостей пустой и этот хук выполнится один раз. при создании

```js
useEffect(() => {
    localStorage.setItem('todos', JSON.stringify(state))
}, [todos])
```
В данном примере в зависимости указан стейт `todos` 
и при каждом изменении этого стейта будет запускаться колбек-функция (будет сохранять его в сторедж).


### Примечание

При использовании с зависимостями и  в связке со строгим режимом, могут запускаться несколько раз события
Так оборачивается главный компонент по умолчанию
```js
<React.StrictMode>
    <App />
</React.StrictMode>
```
Для отключения, просто удаляем еги `React.StrictMode`

Данная проблема не будет на проде,
так-как строгий режим запускат только при отладке несколько раз рендеринг,
из-за чего и могут запускаться повторно события, если они вызываются через `reduser`

 

----------

## Ленивая загрузка компонентов


